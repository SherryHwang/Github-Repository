C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\Objects\IIC.obj
COMPILER INVOKED BY: D:\Software\C51\C51\BIN\C51.EXE IIC\IIC.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\IIC;.\LCD1602;.\DELAY;.
                    -\PCF8591;.\SENSOR;.\USER;.\7SEG;.\WIFI;.\DEFINE;.\DS18B20;.\ELECTRONIC_SCALE;..\MCU_TEST;.\LATTICE;.\ADXL345;.\BH1750) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\IIC.lst) TABS(2) OBJECT(.\Objects\IIC.obj)

line level    source

   1          
   2          /*************************此部分为I2C总线的驱动程序*************************************/
   3          
   4          #include<reg52.h>
   5          #include <intrins.h>
   6          #include "IIC.h"
   7          
   8          #define  NOP()   _nop_()   /* 定义空指令 */
   9          #define  _Nop()  _nop_()   /*定义空指令*/
  10          
  11          bit ack;                 /*应答标志位*/
  12          extern uchar num; 
  13          
  14          /*******************************************************************
  15                               起动总线函数               
  16          函数原型: void  Start_I2c();  
  17          功能:     启动I2C总线,即发送I2C起始条件.  
  18          ********************************************************************/
  19          void Start_I2c()
  20          {
  21   1        if(num == 12)  //BH1750 数字光强
  22   1        {
  23   2          SDA_BH1750=1;         /*发送起始条件的数据信号*/
  24   2          _Nop();
  25   2          SCL_BH1750=1;
  26   2          _Nop();        /*起始条件建立时间大于4.7us,延时*/
  27   2          _Nop();
  28   2          _Nop();
  29   2          _Nop();
  30   2          _Nop();    
  31   2          SDA_BH1750=0;         /*发送起始信号*/
  32   2          _Nop();        /* 起始条件锁定时间大于4μs*/
  33   2          _Nop();
  34   2          _Nop();
  35   2          _Nop();
  36   2          _Nop();       
  37   2          SCL_BH1750=0;       /*钳住I2C总线，准备发送或接收数据 */
  38   2          _Nop();
  39   2          _Nop();
  40   2        }
  41   1        else if(num == 15)  //ADXL345 三轴加速度
  42   1        {
  43   2          SDA_ADXL345=1;         /*发送起始条件的数据信号*/
  44   2          _Nop();
  45   2          SCL_ADXL345=1;
  46   2          _Nop();        /*起始条件建立时间大于4.7us,延时*/
  47   2          _Nop();
  48   2          _Nop();
  49   2          _Nop();
  50   2          _Nop();    
  51   2          SDA_ADXL345=0;         /*发送起始信号*/
  52   2          _Nop();        /* 起始条件锁定时间大于4μs*/
  53   2          _Nop();
C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 2   

  54   2          _Nop();
  55   2          _Nop();
  56   2          _Nop();       
  57   2          SCL_ADXL345=0;       /*钳住I2C总线，准备发送或接收数据 */
  58   2          _Nop();
  59   2          _Nop();
  60   2        }
  61   1        else
  62   1        {
  63   2          SDA=1;         /*发送起始条件的数据信号*/
  64   2          _Nop();
  65   2          SCL=1;
  66   2          _Nop();        /*起始条件建立时间大于4.7us,延时*/
  67   2          _Nop();
  68   2          _Nop();
  69   2          _Nop();
  70   2          _Nop();    
  71   2          SDA=0;         /*发送起始信号*/
  72   2          _Nop();        /* 起始条件锁定时间大于4μs*/
  73   2          _Nop();
  74   2          _Nop();
  75   2          _Nop();
  76   2          _Nop();       
  77   2          SCL=0;       /*钳住I2C总线，准备发送或接收数据 */
  78   2          _Nop();
  79   2          _Nop();
  80   2        }
  81   1      }
  82          
  83          /*******************************************************************
  84                                结束总线函数               
  85          函数原型: void  Stop_I2c();  
  86          功能:     结束I2C总线,即发送I2C结束条件.  
  87          ********************************************************************/
  88          void Stop_I2c()
  89          {
  90   1        if(num == 12)       //BH1750 数字光强
  91   1        {
  92   2          SDA_BH1750=0;      /*发送结束条件的数据信号*/
  93   2          _Nop();       /*发送结束条件的时钟信号*/
  94   2          SCL_BH1750=1;      /*结束条件建立时间大于4μs*/
  95   2          _Nop();
  96   2          _Nop();
  97   2          _Nop();
  98   2          _Nop();
  99   2          _Nop();
 100   2          SDA_BH1750=1;      /*发送I2C总线结束信号*/
 101   2          _Nop();
 102   2          _Nop();
 103   2          _Nop();
 104   2          _Nop();
 105   2        }
 106   1        else if(num == 15)    //ADXL345 三轴加速度
 107   1        {
 108   2          SDA_ADXL345=0;      /*发送结束条件的数据信号*/
 109   2          _Nop();       /*发送结束条件的时钟信号*/
 110   2          SCL_ADXL345=1;      /*结束条件建立时间大于4μs*/
 111   2          _Nop();
 112   2          _Nop();
 113   2          _Nop();
 114   2          _Nop();
 115   2          _Nop();
C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 3   

 116   2          SDA_ADXL345=1;      /*发送I2C总线结束信号*/
 117   2          _Nop();
 118   2          _Nop();
 119   2          _Nop();
 120   2          _Nop();
 121   2        }
 122   1        else
 123   1        {
 124   2          SDA=0;      /*发送结束条件的数据信号*/
 125   2          _Nop();       /*发送结束条件的时钟信号*/
 126   2          SCL=1;      /*结束条件建立时间大于4μs*/
 127   2          _Nop();
 128   2          _Nop();
 129   2          _Nop();
 130   2          _Nop();
 131   2          _Nop();
 132   2          SDA=1;      /*发送I2C总线结束信号*/
 133   2          _Nop();
 134   2          _Nop();
 135   2          _Nop();
 136   2          _Nop();
 137   2        }
 138   1      }
 139          
 140          /*******************************************************************
 141                           字节数据发送函数               
 142          函数原型: void  SendByte(UCHAR c);
 143          功能:     将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
 144                    此状态位进行操作.(不应答或非应答都使ack=0)     
 145                     发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
 146          ********************************************************************/
 147          void  SendByte(uchar c)
 148          {
 149   1       uchar BitCnt;
 150   1       if(num == 12)
 151   1       {
 152   2         for(BitCnt=0;BitCnt<8;BitCnt++)  /*要传送的数据长度为8位*/
 153   2          {
 154   3           if((c<<BitCnt)&0x80) SDA_BH1750=1;   /*判断发送位*/
 155   3             else  SDA_BH1750=0;                
 156   3           _Nop();
 157   3           SCL_BH1750=1;               /*置时钟线为高，通知被控器开始接收数据位*/
 158   3            _Nop(); 
 159   3            _Nop();             /*保证时钟高电平周期大于4μs*/
 160   3            _Nop();
 161   3            _Nop();
 162   3            _Nop();         
 163   3           SCL_BH1750=0; 
 164   3          }
 165   2          
 166   2          _Nop();
 167   2          _Nop();
 168   2          SDA_BH1750=1;                /*8位发送完后释放数据线，准备接收应答位*/
 169   2          _Nop();
 170   2          _Nop();   
 171   2          SCL_BH1750=1;
 172   2          _Nop();
 173   2          _Nop();
 174   2          _Nop();
 175   2          if(SDA_BH1750==1)ack=0;     
 176   2             else ack=1;        /*判断是否接收到应答信号,全局变量*/
 177   2          SCL_BH1750=0;
C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 4   

 178   2          _Nop();
 179   2          _Nop();
 180   2       }
 181   1       else if(num == 15)
 182   1       {
 183   2         for(BitCnt=0;BitCnt<8;BitCnt++)  /*要传送的数据长度为8位*/
 184   2          {
 185   3           if((c<<BitCnt)&0x80) SDA_ADXL345=1;   /*判断发送位*/
 186   3             else  SDA_ADXL345=0;                
 187   3           _Nop();
 188   3           SCL_ADXL345=1;               /*置时钟线为高，通知被控器开始接收数据位*/
 189   3            _Nop(); 
 190   3            _Nop();             /*保证时钟高电平周期大于4μs*/
 191   3            _Nop();
 192   3            _Nop();
 193   3            _Nop();         
 194   3           SCL_ADXL345=0; 
 195   3          }
 196   2          
 197   2          _Nop();
 198   2          _Nop();
 199   2          SDA_ADXL345=1;                /*8位发送完后释放数据线，准备接收应答位*/
 200   2          _Nop();
 201   2          _Nop();   
 202   2          SCL_ADXL345=1;
 203   2          _Nop();
 204   2          _Nop();
 205   2          _Nop();
 206   2          if(SDA_ADXL345==1)ack=0;     
 207   2             else ack=1;        /*判断是否接收到应答信号,全局变量*/
 208   2          SCL_ADXL345=0;
 209   2          _Nop();
 210   2          _Nop();
 211   2       }
 212   1       else
 213   1       {
 214   2         for(BitCnt=0;BitCnt<8;BitCnt++)  /*要传送的数据长度为8位*/
 215   2          {
 216   3           if((c<<BitCnt)&0x80) SDA=1;   /*判断发送位*/
 217   3             else  SDA=0;                
 218   3           _Nop();
 219   3           SCL=1;               /*置时钟线为高，通知被控器开始接收数据位*/
 220   3            _Nop(); 
 221   3            _Nop();             /*保证时钟高电平周期大于4μs*/
 222   3            _Nop();
 223   3            _Nop();
 224   3            _Nop();         
 225   3           SCL=0; 
 226   3          }
 227   2          
 228   2          _Nop();
 229   2          _Nop();
 230   2          SDA=1;                /*8位发送完后释放数据线，准备接收应答位*/
 231   2          _Nop();
 232   2          _Nop();   
 233   2          SCL=1;
 234   2          _Nop();
 235   2          _Nop();
 236   2          _Nop();
 237   2          if(SDA==1)ack=0;     
 238   2             else ack=1;        /*判断是否接收到应答信号,全局变量*/
 239   2          SCL=0;
C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 5   

 240   2          _Nop();
 241   2          _Nop();
 242   2        }
 243   1      }
 244          
 245          /*******************************************************************
 246                           字节数据接收函数               
 247          函数原型: UCHAR  RcvByte();
 248          功能:        用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
 249                    发完后请用应答函数应答从机。  
 250          ********************************************************************/    
 251          uchar   RcvByte()
 252          {
 253   1        unsigned char  retc;
 254   1        unsigned char  BitCnt;
 255   1        if(num == 12)
 256   1        {
 257   2          retc=0; 
 258   2          SDA_BH1750=1;                     /*置数据线为输入方式*/
 259   2          for(BitCnt=0;BitCnt<8;BitCnt++)
 260   2          {
 261   3            _Nop();           
 262   3            SCL_BH1750=0;                  /*置时钟线为低，准备接收数据位*/
 263   3            _Nop();
 264   3            _Nop();                 /*时钟低电平周期大于4.7μs*/
 265   3            _Nop();
 266   3            _Nop();
 267   3            _Nop();
 268   3            SCL_BH1750=1;                  /*置时钟线为高使数据线上数据有效*/
 269   3            _Nop();
 270   3            _Nop();
 271   3            retc=retc<<1;
 272   3            if(SDA_BH1750==1)retc=retc+1;  /*读数据位,接收的数据位放入retc中 */
 273   3            _Nop();
 274   3            _Nop(); 
 275   3          }
 276   2          SCL_BH1750=0;    
 277   2          _Nop();
 278   2          _Nop();
 279   2          return(retc);
 280   2        }
 281   1        else if(num == 15)
 282   1        {
 283   2          retc=0; 
 284   2          SDA_ADXL345=1;                     /*置数据线为输入方式*/
 285   2          for(BitCnt=0;BitCnt<8;BitCnt++)
 286   2          {
 287   3            _Nop();           
 288   3            SCL_ADXL345=0;                  /*置时钟线为低，准备接收数据位*/
 289   3            _Nop();
 290   3            _Nop();                 /*时钟低电平周期大于4.7μs*/
 291   3            _Nop();
 292   3            _Nop();
 293   3            _Nop();
 294   3            SCL_ADXL345=1;                  /*置时钟线为高使数据线上数据有效*/
 295   3            _Nop();
 296   3            _Nop();
 297   3            retc=retc<<1;
 298   3            if(SDA_ADXL345==1)retc=retc+1;  /*读数据位,接收的数据位放入retc中 */
 299   3            _Nop();
 300   3            _Nop(); 
 301   3          }
C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 6   

 302   2          SCL_ADXL345=0;    
 303   2          _Nop();
 304   2          _Nop();
 305   2          return(retc);
 306   2        }
 307   1        else
 308   1        {
 309   2          retc=0; 
 310   2          SDA=1;                     /*置数据线为输入方式*/
 311   2          for(BitCnt=0;BitCnt<8;BitCnt++)
 312   2          {
 313   3            _Nop();           
 314   3            SCL=0;                  /*置时钟线为低，准备接收数据位*/
 315   3            _Nop();
 316   3            _Nop();                 /*时钟低电平周期大于4.7μs*/
 317   3            _Nop();
 318   3            _Nop();
 319   3            _Nop();
 320   3            SCL=1;                  /*置时钟线为高使数据线上数据有效*/
 321   3            _Nop();
 322   3            _Nop();
 323   3            retc=retc<<1;
 324   3            if(SDA==1)retc=retc+1;  /*读数据位,接收的数据位放入retc中 */
 325   3            _Nop();
 326   3            _Nop(); 
 327   3          }
 328   2          SCL=0;    
 329   2          _Nop();
 330   2          _Nop();
 331   2          return(retc);
 332   2        }
 333   1      }
 334          
 335          /********************************************************************
 336                               应答子函数
 337          函数原型:  void Ack_I2c(bit a);
 338          功能:      主控器进行应答信号(可以是应答或非应答信号，由位参数a决定)
 339          ********************************************************************/
 340          void Ack_I2c(bit a)
 341          {
 342   1        if(num == 12)
 343   1        {
 344   2          if(a==0)SDA_BH1750=0;              /*在此发出应答或非应答信号 */
 345   2          else SDA_BH1750=1;
 346   2          _Nop();
 347   2          _Nop();
 348   2          _Nop();      
 349   2          SCL_BH1750=1;
 350   2          _Nop();
 351   2          _Nop();                    /*时钟低电平周期大于4μs*/
 352   2          _Nop();
 353   2          _Nop();
 354   2          _Nop();  
 355   2          SCL_BH1750=0;                     /*清时钟线，钳住I2C总线以便继续接收*/
 356   2          _Nop();
 357   2          _Nop();  
 358   2        }
 359   1        else if(num == 15)
 360   1        {
 361   2          if(a==0)SDA_ADXL345=0;              /*在此发出应答或非应答信号 */
 362   2          else SDA_ADXL345=1;
 363   2          _Nop();
C51 COMPILER V9.56.0.0   IIC                                                               08/10/2018 20:37:17 PAGE 7   

 364   2          _Nop();
 365   2          _Nop();      
 366   2          SCL_ADXL345=1;
 367   2          _Nop();
 368   2          _Nop();                    /*时钟低电平周期大于4μs*/
 369   2          _Nop();
 370   2          _Nop();
 371   2          _Nop();  
 372   2          SCL_ADXL345=0;                     /*清时钟线，钳住I2C总线以便继续接收*/
 373   2          _Nop();
 374   2          _Nop();
 375   2        }
 376   1        else
 377   1        {
 378   2          if(a==0)SDA=0;              /*在此发出应答或非应答信号 */
 379   2          else SDA=1;
 380   2          _Nop();
 381   2          _Nop();
 382   2          _Nop();      
 383   2          SCL=1;
 384   2          _Nop();
 385   2          _Nop();                    /*时钟低电平周期大于4μs*/
 386   2          _Nop();
 387   2          _Nop();
 388   2          _Nop();  
 389   2          SCL=0;                     /*清时钟线，钳住I2C总线以便继续接收*/
 390   2          _Nop();
 391   2          _Nop();  
 392   2        }   
 393   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    527    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
